#!/usr/bin/env python
import re,sys,os,argparse
from argparse import RawTextHelpFormatter

###################################################
### 0. script description and parsing arguments ###
###################################################
synopsis1 = "\
  from a summary of OrthNets or OrthoFinder clusters, or any tab-delimited\n\
  table that includes copy numbers for each species, one gene cluter per line\n\
  and print lines that meet copy number criterion listed in the query.\n"
synopsis2 = "detailed description:\n\
 1. Input files and parameters:\n\
  - './<Project>.list' includes all species IDs (spcsIDs), one species per line.\n\n\
  - '<nodeCN_query>': a tab-delimited list of queriess, one per line; each\n\
     query contains the queryID, a query mode ({A,B,C}), and a node copy number\n\
     (nodeCN) criterion as described below:\n\
    (A) the nodeCN criterion as in 'search_OrthNet_pattern.py'; i.e. a list of\n\
      nodeCN criteria as exact intergers or 'min|max' to indicate a range, e.g.\n\
         '0|2' means the same or less than 2 copies;\n\
         '2|~' means the same or more than 2 copies;\n\
         '0|~' all values accepted, etc;\n\
      in the order of species as appearing in <Project>; e.g. when <Project>\n\
      includes six species, the query will look like:\n\
         queryID1\ta\t0|~\t1\t2|~\t1\t1|2\t0|2\n\
    (B) 'query species' and 'background species' separated by a tab; the minimum\n\
      copy number among the query species must be greater than the maximum among\n\
      the background species, e.g. the following query:\n\
         queryID2\tb\ts1,s2,s4\ts3,s6,s8,s9,s11\n\
      selects only if s1, s2, and s4 all have copy numbers higher than any of\n\
      the five background species, s3, s6, s8, s9, and s11,\n\
    (C) at least N species among 'query species' must meet the nodCN criterion;\n\
      for example, the following query:\n\
         queryID3\tc\ts2,s3,s5,s6,s8,s9;3;1|~\n\
      selects if at least three out of the six query species contain one or more\n\
      nodes (or orthologues),\n\
    (combinations of A, B, and C) multiple queries with different modes with the\n\
      same queryID will select only those meeting all criteria.\n\n\
  - <nodeCN_target>: a tab-delimited file that includes copy numbers for each\n\
     species listed in <Project>, for each OrthNet or other orthologous gene\n\
     cluster (e.g. generated by OrthoFinder), one cluster per line; the header\n\
     line must include all spcsIDs in <Project>; nodeCN information for each\n\
     species is expected in the same column, under each spcsID in the header;\n\
     this input can be generated by one of the following scripts:\n\
         parse_mclOutput.py -s|S (for OrthNets or OrthoFinder/OrthoMCL clusters)\n\
         cluster_OrthNets_topology_exact.py -e (for OrthNet topologies)\n\n\
 2. Output files and options:\n\
  - <output> prints all lines from <nodeCN_target> that meet a criteria from\n\
     <nodeCN_query>, with the queryID(s) added as the additional last column;\n\
     if a line meet multiple queries, print all queryIDs, separated by comma.\n\
  - '-a': print all lines from <nodeCN_target>, including those did not meet\n\
     any query criterion(default=False).\n\
 by ohdongha@gmail.com ver0.0 20181224\n"
 
#version_history
#20181224 ver 0.0  

parser = argparse.ArgumentParser(description = synopsis1, epilog = synopsis2, formatter_class = RawTextHelpFormatter)

# positional arguments
parser.add_argument('Project', type=str, help="'./<Project>.list' includes spcsIDs being compared")
parser.add_argument('nodeCN_query', type=str, help="see below.")
parser.add_argument('nodeCN_target', type=str, help="see below.")
parser.add_argument('output', type=str, help="see below.")
# options and parameters
parser.add_argument('-a', dest="print_all", action="store_true", default=False) 

args = parser.parse_args()


################################################################
### 1. reading spcsID, nodeCN_query, and nodeCN_target files ###
################################################################
# 1.1 reading fin_SpcsList
try:
	fin_SpcsList = open(args.Project + '.list', 'r')
except IOError:
	fin_SpcsList = open(args.Project, 'r')
print "\nreading the species/genome list file: " + fin_SpcsList.name
projectID = os.path.splitext( os.path.basename( args.Project ) )[0]

spcsID_list = []
for line in fin_SpcsList:
	spcsID_list.append(line.strip())
	print line.strip()
print "Total %d species/genome IDs detected." % (len(spcsID_list))
fin_SpcsList.close()


# 1.2 reading nodeCN_query file
fin_query = open(args.nodeCN_query, 'r')
#print "\nreading node copy number query file: %s," % fin_query.name

qID = ""
qmode = ""
num_query = 0
ndCN_q_dict = dict() # key = qID, value = a dictionary with key = query mode, value = query_string as a list

for line in fin_query:
	tok = line.split('\t')
	if len(tok) > 2 and tok[1].strip() in {'a', 'b', 'c', 'A', 'B', 'C'}:
		qID = tok[0].strip()
		qmode = tok[1].strip()
		if qID not in ndCN_q_dict:
			ndCN_q_dict[ qID ] = dict() # key = query mode, value = query_string as a list
		if qmode not in ndCN_q_dict[ qID ]:
			num_query += 1
			ndCN_q_dict[qID][qmode] = '\t'.join(tok[2:]).strip()
		else:
			print "duplicated queryID and mode, ignored:"
			print line
	else:
		print "An invalid line in the query %s, ignored:" % fin_query.name
		print line

if num_query == 1: 
	print "A single query was read from %s," % fin_query.name
else:
	print "Total %d queries, with %d queryIDs, were read from %s," % ( num_query, len(ndCN_q_dict), fin_query.name )
fin_query.close()
	

# 1.3. reading the nodeCN_target 
fin_target = open(args.nodeCN_target, 'r')

ndCN_dict = dict() # key = line_number as the target ID (tID); value = dict of node CN, with key = spcsID, value = nodeCN
sID_col_dict = dict() # key = spcsID; value = col_number
num_line = 0 # physical line number, also used as the targetID (tID)
nodeCN = 0

for line in fin_target:
	tok = line.split('\t')
	if num_line == 0: # header
		for sID in spcsID_list: 
			if sID in tok:
				sID_col_dict[ sID ] = tok.index( sID ) # parsing the header
			else:
				print "Cannot find speciesID: %s in the header of %s, exiting" % (sID, fin_target.name)
				sys.exit()
	else: # after the header, reading nodeCN for each species
		ndCN_dict[ num_line ] = dict() # key= spcsID, value = nodeCN
		for sID in spcsID_list:
			try:
				nodeCN = int( tok[ sID_col_dict[sID] ] )
			except TypeError:
				print "in line %d, an invalid node copy number detected for %s, use 0 instead" % (num_line, sID)
				print line
				nodeCN = 0
			ndCN_dict[ num_line ][ sID ] = nodeCN
	num_line += 1
print "Total %d lines read from %s, now filtering ..." % ( num_line, fin_target.name )
	
################################################################
### 2. filtering lines in nodeCN_target and printing results ###
################################################################
# 2.1 filtering lines in nodeCN_target
selected_dict = dict() # key = qID, value = set of targetID (tID) that met ndCN creteria of the qID query
tID_list = []
keep = True

for qID in ndCN_q_dict:	
	for qmode in sorted( ndCN_q_dict[qID] ): # qmode is either a, b, or c
		if qID not in selected_dict: 
			selected_dict[qID] = set() 
			for tID in ndCN_dict:
				selected_dict[qID].add(tID) # start with all targetIDs (tIDs)				
			
		## mode A
		if qmode == 'a' or qmode == 'A':
			# read in the query
			process_filter = True
			min_ndCN_dict = dict() # key = spcsID, value = min_ndCN
			max_ndCN_dict = dict() # key = spcsID, value = max_ndCN
			tok_ndCN_q = ndCN_q_dict[qID][qmode].split('\t')
			if len( tok_ndCN_q ) >= len( spcsID_list ):
				n = 0
				for sID in spcsID_list:
					tok_ndCN_q_each = tok_ndCN_q[n].strip().split('|')
					if len( tok_ndCN_q_each ) == 1:
						try:
							min_ndCN_dict[sID] = int( tok_ndCN_q_each[0] ) 
							max_ndCN_dict[sID] = min_ndCN_dict[sID] 
						except TypeError:
							print "Warning: an invalid value given as a node copy number query, ignoring: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
							min_ndCN_dict[sID] = 0
							max_ndCN_dict[sID] = 9999 						
					elif len( tok_ndCN_q_each ) >= 2:
						try:
							min_ndCN_dict[sID] = int( tok_ndCN_q_each[0] ) 
						except TypeError:
							print "Warning: an invalid value given as a node copy number query, ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
							min_ndCN_dict[sID] = 0								
						if tok_ndCN_q_each[1] == '~':
							max_ndCN_dict[sID] = 9999
						else:
							try:
								max_ndCN_dict[sID] = int( tok_ndCN_q_each[1] ) 
							except TypeError:
								print "Warning: an invalid value given as a node copy number query, ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
								max_ndCN_dict[sID] = 9999
					n += 1
			else:
				print "Not enough columns for an mode A query, query ignored: %s %s %s" % (qID, qmode, ndCN_q_dict[qID][qmode])
				provess_filter = False
		
			#iterate over selected_dic[qID]
			if process_filter:
				tID_list = list( selected_dict[qID] ) # get a list to iterate on
				for tID in sorted( tID_list ):
					keep = True
					for sID in spcsID_list:
						if ndCN_dict[tID][sID] < min_ndCN_dict[sID] or ndCN_dict[tID][sID] > max_ndCN_dict[sID]:
							keep = False
							break
					if not keep:
						selected_dict[qID].remove(tID)
		
		## mode B
		elif qmode == 'b' or qmode == 'B':
			# read in the query
			process_filter = True
			qr_spcsIDs = [] # list of query spcsIDs
			bg_spcsIDs = [] # list of background spcsIDs
			tok_ndCN_q = ndCN_q_dict[qID][qmode].split('\t')
			if len( tok_ndCN_q ) >= 2:
				qr_spcsIDs = tok_ndCN_q[0].strip().split(',')
				bg_spcsIDs = tok_ndCN_q[1].strip().split(',')
				for sID in qr_spcsIDs:
					if sID not in spcsID_list:
						#print "Warning: an invalid value given as a query spcsID, ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
						qr_spcsIDs.remove(sID)
				for sID in bg_spcsIDs:
					if sID not in spcsID_list:
						#print "Warning: an invalid value given as a query spcsID, ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
						bg_spcsIDs.remove(sID)
			if len( qr_spcsIDs ) * len( bg_spcsIDs ) == 0:
				print "Warning: either query or background species not given, query ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
				process_filter = False
			
					
			#iterate over selected_dic[qID]
			if process_filter:
				tID_list = list( selected_dict[qID] ) # get a list to iterate on
				for tID in sorted( tID_list ):
					# initialize
					keep = True
					min_among_qr = 9999
					max_among_bg = 0
					# get min_among_qr and max_among_bg
					for sID in qr_spcsIDs:
						if ndCN_dict[tID][sID] < min_among_qr: 
							min_among_qr = ndCN_dict[tID][sID]
					for sID in bg_spcsIDs:
						if ndCN_dict[tID][sID] > max_among_bg: 
							max_among_bg = ndCN_dict[tID][sID]
					# decide whether to keep or not
					if min_among_qr <= max_among_bg:
						keep = False
					if not keep:
						selected_dict[qID].remove(tID)
			
		elif qmode == 'c' or qmode == 'C':
			# read in the query
			process_filter = True
			qr_spcsIDs = [] # list of query spcsIDs
			min_num_sID_survived = 0
			min_ndCN = 0
			max_ndCN = 0
			tok_ndCN_q = ndCN_q_dict[qID][qmode].split(';')
			try: 
				qr_spcsIDs = tok_ndCN_q[0].strip().split(',')
				for sID in qr_spcsIDs:
					if sID not in spcsID_list:
						#print "Warning: an invalid value given as a query spcsID, ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
						qr_spcsIDs.remove(sID)
				min_num_sID_survived = int( tok_ndCN_q[1] )
				if min_num_sID_survived > len(qr_spcsIDs):
					raise AssertionError
				if len( tok_ndCN_q[2].split('|') ) == 1:
					try:
						min_ndCN = int( tok_ndCN_q[2].strip() )
						max_ndCN = min_ndCN
					except TypeError:
						print "Warning: an invalid value given as a node copy number query, ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
						min_ndCN = 0
						max_ndCN = 9999
				elif len( tok_ndCN_q[2].split('|') ) >= 2:
					min_ndCN = int( tok_ndCN_q[2].split('|')[0].strip() )
					if tok_ndCN_q[2].split('|')[1].strip() == '~':
						max_ndCN = 9999
					else:
						max_ndCN = int( tok_ndCN_q[2].split('|')[1].strip() )
			except TypeError:
				print "Warning: an invalid value given as a node copy number query, ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
				process_filter = False
			except IndexError:
				print "Warning: the query missing a required field, ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
				process_filter = False
			except AssertionError:
				print "Warning: number of species that needs to meet the nodeCN creterion is larger than the number of total query species , query ignored: %s %s %s"  % (qID, qmode, ndCN_q_dict[qID][qmode])
				process_filter = False
							
			#iterate over selected_dic[qID]	
			if process_filter:
				tID_list = list( selected_dict[qID] ) # get a list to iterate on
				for tID in sorted( tID_list ):
					# initialize
					keep = True
					num_sID_survived = 0
					# count
					for sID in qr_spcsIDs:
						if ndCN_dict[tID][sID] >= min_ndCN and ndCN_dict[tID][sID] <= max_ndCN:
							num_sID_survived += 1
					# decide whether to keep or not
					if num_sID_survived < min_num_sID_survived:
						keep = False
					if not keep:
						selected_dict[qID].remove(tID)
					
		else:
			print "query should have a mode either A, B, or C: %s %s %s" % (qID, qmode, ndCN_q_dict[qID][qmode])

# 2.2 mark each tID with qIDs
tID_qID_dict = dict() # key = tID, value = list of qIDs that the tID has satisfied,
for tID in ndCN_dict:
	tID_qID_dict[tID] = set()
	for qID in ndCN_q_dict:
		if tID in selected_dict[qID]:
			tID_qID_dict[tID].add(qID)
		
print "Finished filtering, now printint results to %s," % args.output

# 2.3 printing results
fout = open(args.output, "w")
fin_target.seek(0) # going back to the beginning
n = 0
num_annotated = 0

for line in fin_target:
	if n == 0:
		fout.write(line.strip() + "\tndCN_queries\n") # adding a column at the endswith
	else:
		if len( tID_qID_dict[n] ) == 0:
			if args.print_all:
				fout.write(line.strip() + "\t-\n")
		else:
			fout.write(line.strip() + '\t' + ','.join( sorted(list( tID_qID_dict[n] ) ) ) + '\n')
			num_annotated += 1
	n += 1

print "done printing to %s; total %d lines were annotated with at least one query." % (fout.name, num_annotated)
fin_target.close()
fout.close()
